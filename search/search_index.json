{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Messy","text":"<p>The availability of simulation platforms is a key ingredient for making RISC-V based hardware solutions pervasive. Simulators represent a cost-effective and scalable solution that enable rapid prototyping without the need for physical hardware. For these reasons, there is a growing availability of programs designed to simulate entire RISC-V chips. Some options include QEMU, Simulink, Renode, and GVSoC. However, these tools present some limitations. Most of them only simulate the computing core with scarce possibilities to perform system-level simulations. Moreover, they simulate only functional features, with poor support for extra-functional properties such as power consumption. This work tries to address these challenges by presenting a flexible simulator.</p> <p>Messy is an open-source framework that integrates functional RISC-V simulation (achieved with GVSoC for the PULP cores) with SystemC-AMS (used to model extra-functional aspects, in detail power storage and distribution). The combination of GVSoC and SystemC-AMS in a single simulation framework allows to perform a DSE that is dependent on the mutual impact between functional and extra-functional aspects. </p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, please refer to the Getting Started</p>"},{"location":"codegen/","title":"Codegen","text":"<p>This module will explain the codegen process with its characteristics.</p> <p>The codegen is a Python script that generates the code for the simulation. It is located in the <code>messy/codegen</code> folder. The codegen is composed of two files:</p> <ul> <li><code>codegen.py</code>: this is the main file of the codegen. It contains the call to specific functions that will generate the code of the components of the simulator.</li> </ul>"},{"location":"codegen/#codegen-explanation","title":"Codegen explanation","text":"<p>The <code>codegen.py</code> expect a JSON file as input, which contains the configuration for the simulator. </p> <p>An example of a JSON file is the following:</p> <pre><code>{\n    \"resolution\":\"SC_MS\",\n    \"tracing\":{\n        ...\n    },\n    \"bus\":{\n        \"vref\":3.3\n    },\n    \"core\":{\n        \"vref\":1.8,\n        \"iss\":\"gvsoc\",\n        \"config\":{\n            \"path\":\"./gvsoc_config.json\",\n            \"axi_path\":\"/chip/axi_proxy\"\n        },\n        ...\n    },\n    \"peripherals\":{\n        \"sensors\" : {\n            \"mic_click\": {\n                ...\n            }\n        },\n        \"harvesters\":{\n            \"battery\" : {\n                ...\n            },\n            \"photovoltaic\" : {\n                ...\n            }\n        }\n    }\n}\n</code></pre> <p>In this case for example, we are describing a single sensor. The meaning of different fields is the following:</p> <ul> <li><code>resolution</code>: this is the simulation resolution using <code>sc_unit</code> values. For more details refer to Resolution</li> <li><code>tracing</code>: tracing is better described in Tracing </li> <li> <p><code>bus</code>: the bus object contains all the relative informations about it, which currently resides only in its reference voltage in Volts.</p> </li> <li> <p><code>core</code>: definition of the simulated core (system), to define one we can use the following parameters</p> <ul> <li><code>vref</code>: reference voltage in Volts</li> <li><code>config</code>: configuration of the ISS, which considers path of files and address of the AXI currently </li> </ul> </li> <li> <p><code>converters</code>: Messy also supports converters. Read more at Converters</p> </li> <li> <p><code>peripherals</code>: set of sensors (better described Sensors) and harvesters (better described in Harvesters)</p> </li> </ul>"},{"location":"codegen/#further-details","title":"Further Details","text":"<p>If we expand the configuration of a sensor, we can see something like this:</p> <pre><code>    \"peripherals\":{\n        \"sensors\" : {\n            \"mic_click\": {\n                \"power\": true,\n                \"tracing\":{\n                    \"messy_trace\":{\n                        \"mic_click_I\":\"current\"\n                    }\n                },\n                \"vref\": 3.3,\n                \"register_memory\" : 256,\n                \"states\":{\n                    \"read\" : {\n                        \"current\" : \"0.12\",\n                        \"delay\" : \"30\"\n                    },\n                    \"write\": {\n                        \"current\" : \"0.16\",\n                        \"delay\" : \"30\"\n                    },\n                    \"idle\":{\n                        \"current\" : \"0.002\"\n                    }\n                }\n            }\n        },\n</code></pre>"},{"location":"codegen/#memory","title":"Memory","text":"<p>As we can see, there is a field called <code>register_memory</code>. This takes into account the memory space of the sensor (it can be seen as a MMIO). This is managed by the following lines of code in the <code>codegen.py</code>:</p> <pre><code>for idx,(sensor_name,sensor) in enumerate(settings[\"peripherals\"][\"sensors\"].items()):\n    sensor[\"base\"] = baseaddress\n    sensor[\"ID\"] = idx\n    baseaddress += 1 + sensor[\"register_memory\"]\n</code></pre> <p>This loops over all the sensors in the JSON configuration file and assign the <code>baseaddress</code> to that sensor. For this reason, if we want one sensor before the other in the memory, is importan to define them correctly. The <code>baseaddress</code> is not to be confused with the <code>AXI_BASE</code>. In fact, GVSoC has some memory space that is fixed and cannot be touched, otherwise it causes segmantation faults. After that memory space, there is available memory space where the user can write whatever is needed.</p> <pre><code>...\n#define AXI_BASE 0x20000000\n...\nint main(void)\n{\n    ...\n\n    int* mic_click_sensor = (volatile int *)AXI_BASE+0x0;\n    ...\n}\n</code></pre> <p>As we can see in the code example (taken from the <code>read_sensor.c</code>), to define the address of the <code>mic_click_sensor</code> we just need to add <code>0x0</code> to the <code>AXI_BASE_ADDRESS</code>. This is because the used configuration, which is the <code>pulp_open.json</code>, only contains one sensor. </p> <p>Supposing we have two sensors with a <code>memory_map</code> of 256 and we want to access the memory of the second one, we should add to <code>AXI_BASE</code> the offset (which is 256) with the respect to the starting address. </p> Name Base Address Memory Register Size Offset w.r.t AXI_BASE AXI_BASE 0x20000000 - 0 sensor1 0x20000000 256 0 sensor2 0x20000256 256 256 <p>Check with Amine if it is correct</p>"},{"location":"codegen/#states","title":"States","text":"<p>Another important detail is the presence of different states. At the moment each sensor only supports 3 states:</p> <ol> <li>Read: the sensor is reading from the memory</li> <li>Write: the sensor is writing to the memory</li> <li>Idle: the sensor is idle</li> </ol> <p>Inside this states we can define the current drawn to execute that operation and the delay. The delay of the cycles follows the same resolution of the global resolution of the system, which is defined at the beginning of the JSON file.</p> <pre><code>{\n    \"resolution\":\"SC_MS\",\n    ...\n}\n</code></pre> <p>Warning</p> <p>Right now, messy only supports global configuration for the resolution of the delay of the sensors.</p> <p>These states, at the moment, are managed in the following way:</p> <ul> <li>Idle<ul> <li>Read<ul> <li>Idle</li> </ul> </li> <li>Write<ul> <li>Idle</li> </ul> </li> </ul> </li> </ul>"},{"location":"converters/","title":"Converters","text":"<p>Converters are very important objects in electronics system, they are supported in MESSY currently by a LUT approach, here an example of a converter:</p> <pre><code>\"converter\" : {\n    \"input_variable\":\"voltage\",\n    \"out_dir\":false,\n    \"lut\":{\n        \"input_values\":[0.6559,0.7397,0.8363,0.9588,1.0941,1.1907,1.4291,1.7642,1.8544,1.9961,2.4278,2.5954,2.6534,2.7307,2.7758,2.7887,2.9691,3.1688,3.3428,3.5876,3.7874,3.9678,4.1353,4.3673,4.5928,4.7668,4.9729],\n        \"efficiency_values\":[64.92,69.37,74.44,78.79,81.87,83.69,84.77,85.86,86.04,85.95,89.31,90.66,83.14,75.71,70.73,68.46,68.64,68.19,66.83,63.93,61.75,59.31,57.22,54.77,52.42,50.51,47.70]\n    }\n}\n</code></pre> <p>The converter is described through the direction, set by <code>out_dir</code>, that we want to consider, the <code>input_variable</code> that we want to consider, that can be either voltage or current and finally the previously mentioned LUT, the LUT second values for a converter are the <code>efficiency_values</code>, which are the efficiency percentages of a converter.</p> <p>The modeled converter can be described as a simple Buck DC-DC converter, but we want to support a wider variety of converters. </p>"},{"location":"debugging/","title":"Debugging","text":"<p>This guide explains how to debug the code. The provided configuration needs Visual Studio Code. For other IDEs, you need to adapt the configuration. The whole configuration is provided in the <code>.vscode</code> folder. Everything should work out of the box. </p> <p>You have to create a docker container first. See Getting Started for more information.</p> <p>Important</p> <p>After that you need to install the Visual Studio Code <code>Remote - Containers</code> and <code>C/C++</code> extensions. You can find them here and here respectively. </p> <p>After that, you will find a docker icon in left bar. If you click it, it will show you the list of containers. You should see the container you created before. If you right click on it and select <code>Attach Visual Studio Code</code>, it will open a new window with the container attached.</p> <p>Important</p> <p>You have to install the <code>C/C++</code>  extension in the container too. You find the link here.</p> <p>Then you can open the folder <code>/messy</code> and click on the debug icon (green circle in the picture below) in the left bar. You should see a list of debug configurations. The one we are interested in is called <code>gdb</code> (red circle in the picture below). If you click on it, it will start the debugger. You can set breakpoints and step through the code.</p> <p></p>"},{"location":"docker/","title":"Docker getting started","text":""},{"location":"docker/#requirements","title":"Requirements","text":"<p>To build a Docker image, you need to have Docker installed on your machine. You can find the installation instructions here. In addition to that you need to populate the <code>deps/</code> directory with the SystemC and SystemC-AMS <code>.tar</code> files. You can find them here and here. The Dockerfile expects the following files:</p> <ul> <li><code>systemc-x.x.x.tar</code></li> <li><code>systemc-ams-x.x.x.tar</code></li> </ul> <p>Warning</p> <p>The <code>x.x.x</code> at the end of the file name of the SystemC and SystemC-AMS files should be replaced by the downloaded version. After that check the <code>Dockerfile</code> to make sure to put the correct version in the <code>COPY</code> command. You need to change the <code>x.x.x</code> in the following line:</p> <pre><code>COPY deps/systemc-2.3.3.tar /systemc.tar\n...\nCOPY deps/systemc-ams-2.3.4.tar /systemc-ams.tar\n</code></pre> <p>Important</p> <p>For compatibility reasons we suggest you to use the following version of SystemC and SystemC-AMS:</p> <ol> <li>SystemC 2.3.3</li> <li>SystemC-AMS 2.3.4</li> </ol>"},{"location":"docker/#overview-of-the-dockerfile","title":"Overview of the Dockerfile","text":"<p>Each Dockerfile is based on the Ubuntu 22.04 image. It installs the following dependencies:</p> <ul> <li>SystemC x.x.x (https://systemc.org/)</li> <li>Systemc-AMS x.x.x (https://www.accellera.org/downloads/standards/systemc)</li> <li>Core SDK</li> <li>Core RISC-V</li> <li>Make</li> <li>CMake</li> <li>g++</li> <li>python3</li> <li>python3-pip</li> </ul>"},{"location":"docker/#build-the-docker-image","title":"Build the Docker image","text":"<p>The first step is to build a Docker image. For example to build the <code>pulp-open</code> container the following command should be issued:</p> <pre><code>docker build . -f docker/pulp-open/Dockerfile -t messy\n</code></pre> <p>The first time you run this command, it will take some time to build the image. Thanks to docker caching, the next time you run this command, it will be much faster.</p>"},{"location":"docker/#run-the-docker-container","title":"Run the Docker container","text":"<p>Once the image is built, you can run the container with the following command:</p> <pre><code>docker run -it --rm -v $(pwd):/messy messy:latest\n</code></pre> <p>This command will run the container and mount the current directory in the <code>/messy</code> directory of the container. This way, you can access the files from the container and the host. Now you should see the shell inside the container.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This document will guide you through the steps to get started with the project.</p>"},{"location":"getting-started/#clone-the-repository","title":"Clone the repository","text":"<p>First, clone the repository to your local machine:</p> <pre><code>git clone https://github.com/eml-eda/messy\n</code></pre>"},{"location":"getting-started/#build-a-docker-image","title":"Build a docker image","text":"<p>For details on what the Dockerfile does and how to build the image, please refer to the Docker getting started file.</p>"},{"location":"getting-started/#run-some-examples","title":"Run some examples","text":"<p>There are a few examples in <code>examples</code> folder, try one of them as is shown in Simulator.</p> <p>You can use one of the configuration or define a new one following the documentation in Codegen.</p>"},{"location":"harvesters/","title":"Harvesters","text":"<p>Harvesters in MESSY are viewed in 2 different categories, batteries and sources. Batteries are more complex and contain by default AMS level simulation, while sources are defined in a simpler way.</p> <p>Currently the power scheduling tries to use all the power generated by the sources to contain the system load and eccesses are handled uniformly by the batteries.</p> <p>In the future, this aspect could be analyzed more and bring more control over power scheduling algorithms,</p>"},{"location":"harvesters/#battery-definition","title":"Battery definition","text":"<p>A battery is defined through several parameters, following an example of a battery called <code>panasonic_batt</code>:</p> <pre><code>\"panasonic_batt\" : {\n    \"harvester_type\":\"battery\",\n    \"tracing\":{\n        ...\n    },\n    \"vref\":3.8,\n    \"soc_init\" : 100,\n    \"soc_end\" : 0,\n    \"capacity\":32,\n    \"self_discharge\":{\n        \"resolution\":{\n            \"unit\":\"SC_S\",\n            \"mult\":1\n        },\n        \"value\":0.001\n    },\n    \"converter\" : {\n        ...\n    }\n}\n</code></pre> <p>The firs parameter is the <code>harvester_type</code> one, this has to be set to battery, then tracing can be set as well.</p> <p>To continue a slate of battery related paramters are present, these are:</p> <ul> <li><code>vref</code>: reference voltage in Volts</li> <li><code>soc_init</code>: starting State of Charge of the battery</li> <li><code>soc_end</code>: battery State of Charge that should trigger the termination of the simulation</li> <li><code>capacity</code>: battery nominal capacity in mAh</li> <li><code>self_discharge</code>: object that represent the self dischargment of a battery, parametrized by a resolution object and a <code>value</code>, each resolution time the value will be discharged from the battery</li> <li><code>converter</code>: optionally MESSY allows harvesters to define a converter (better described in Converters)</li> </ul>"},{"location":"harvesters/#source-definition","title":"Source definition","text":"<p>The sources are defined similarly, here an example:</p> <pre><code>\"photovoltaic\" : {\n    \"harvester_type\" :\"source\",\n    \"vref\" :{\n        \"input_file\":\"input_files/gmonths.txt\",\n        \"lut\":{\n            \"input_values\":[250,500,750,1000],\n            \"voltage_values\":[2.9367,3.0710,3.1334,3.1689]\n        }\n    },\n    \"iref\":{\n        \"input_file\":\"input_files/gmonths.txt\",\n        \"lut\":{\n            \"input_values\":[250,500,750,1000],\n            \"current_values\":[13.4031,27.2251,41.8848,56.7245]\n        }\n    },\n    \"converter\" : {\n        ...\n    }\n}\n</code></pre> <p>The firs parameter is the <code>harvester_type</code> one, this has to be set to source, then tracing can be set as well as a converter.</p> <p>The specific parameters regards the enhanced input values such as <code>iref</code> and <code>vref</code>, these input values can be set statically, or to simulate more precisely natural conditions, they can be retrieved from an input file and generated by a LUT.</p>"},{"location":"how-to-build-docs/","title":"Documentation","text":"<p>Until the project is not public, you can read the documentation in the following way, supposing you are using Visual Studio Code:</p> <p>Clone the repository</p> <pre><code>git clone https://github.com/eml-eda/messy\n</code></pre> <p>Change into the directory</p> <p><pre><code>cd messy\n</code></pre> Open this folder in Visual Studio Code</p> <p>Create a python virtual environment</p> <pre><code>python3 -m venv doc_env\n</code></pre> <p>Activate the virtual environment</p> <pre><code>source doc_env/bin/activate\n</code></pre> <p>Install the dependencies</p> <pre><code>pip3 install -r requirements.txt\n</code></pre> <p>Serve the documentation</p> <pre><code>mkdocs serve\n</code></pre> <p>Now you see something like this:</p> <pre><code>Serving on http://127.0.0.1:8000/\n</code></pre> <p>Visual Studio Code should automatically setup port forwarding. So you can simply open a browser and go to http://127.0.0.1:8000 to see the documentation.</p>"},{"location":"lut/","title":"LUT","text":"<p>LookUp Tables are used in a wide variety of applications, in MESSY they are used to help describe converters and input values files.</p> <p>A LUT is defined through a JSON object containing as following:</p> <pre><code>\"lut\":{\n    \"input_values\":[0.6559,...],\n    \"second_variable\":[64.92,...]\n}\n</code></pre> <p>In this object the user shall set in <code>input_values</code> an array of values representing the input variable(tension, current, nits, torque etc.) and finally should call the second field(<code>efficiency_values</code>, <code>voltage_values</code> and <code>current_values</code>) with an array of the other values.</p>"},{"location":"resolution/","title":"Resolution","text":"<p>A resolution object in MESSY is defined following SystemC timing units, a resolution is comprised of a unit measure (<code>SC_MS</code>, <code>SC_NS</code>, <code>SC_PS</code>) and a multiplier value, below an example that defines 30 seconds:</p> <pre><code>\"resolution\":{\n    \"unit\":\"SC_S\",\n    \"mult\":30\n}\n</code></pre>"},{"location":"sensors/","title":"Sensors","text":"<p>Sensors are important components for this simulator. Every sensor can be composed by two separate instances:</p> <ul> <li>Functional: this instance is responsible for define the internal characteristics of the sensor. This instance interfaces with the core through a bus</li> <li>Power: this instance controls the state of the sensor and exposes its current and voltage</li> </ul> <p>The functional part retrieves details of the request, such as the address, read/write flag, and data from the core. Its logic consists of a structure of if statements where it queries an array of elements (simulated internal registers of the sensor), sets the correct power state, and waits. After this step, the power instance is activated, which updates the power information for a certain amount of time defined by the sensor\u2019s configuration. This is done to simulate the computational time that the sensor takes in real life to analyze the data and update the corresponding register. After that, the power instance sets an IDLE state and gives control back to the functional instance, which can then prepare Data OUT and GO signals to reply to the core.</p>"},{"location":"sensors/#definition","title":"Definition","text":"<p>The sensors are defined together with the rest of the system in a JSON configuration file, below for example there is defined a microphone sensor called <code>mic_click</code>:</p> <pre><code>\"mic_click\": {\n    \"tracing\":{\n        \"messy_trace\":{\n            \"mic_click_I\":\"current\"\n        }\n    },\n    \"vref\": 3.3,\n    \"register_memory\" : 256,\n    \"states\":{\n        \"read\" : {\n            \"current\" : \"0.12\",\n            \"delay\" : \"30\"\n        },\n        \"write\": {\n            \"current\" : \"0.16\",\n            \"delay\" : \"30\"\n        },\n        \"idle\":{\n            \"current\" : \"0.002\"\n        }\n    }\n}\n</code></pre> <p>Each sensor needs a certain amount of memory to interact with the system and this is simulated and setted thanks to the <code>register_memory</code> paramter. </p> <p>Ideally each sensor could define a set of states and model it in those states, however currently the system supports only the reading state, the writing state and an idle state, which are fundamental.</p> <p>Each state is defined considering the current(voltage) needed and optionally a timing <code>delay</code> information(how much does the sensor stay in state).</p> <p>Tracing can be set as described in Tracing.</p> <p>Finally, the information about the reference voltage can be set through the <code>vref</code> parameter.</p>"},{"location":"simulator/","title":"Simulator","text":""},{"location":"simulator/#usage","title":"Usage","text":"<p>To run a simulation you must go into the <code>messy</code> directory:</p> <pre><code>cd /messy/messy/\n</code></pre> <p>Then we can run python:</p> <pre><code>python3 messy.py -f codegen/pulp_open.json -a /messy/examples/helloworld\n</code></pre> <p>This code will build and execute the <code>helloworld</code> example. You should see the following output:</p> <pre><code>Entering main controller\n[31 0] Hello World!\nCluster master core entry\n[0 7] Hello World!\n[0 6] Hello World!\n[0 5] Hello World!\n[0 4] Hello World!\n[0 3] Hello World!\n[0 2] Hello World!\n[0 0] Hello World!\n[0 1] Hello World!\nCluster master core exit\nBye !\n</code></pre>"},{"location":"simulator/#messypy-explanation","title":"Messy.py Explanation","text":"<p>The <code>messy.py</code> python scripts expects 2 arguments:</p> <ol> <li>The first one is the file name of the chosen configuration. In the example, the basic pulp-open configuration is used.</li> <li>The second one if the path of the folder of the application.</li> </ol> <p>MESSY, during the build process, also the C++ SystemC-AMS sources of the used configuration (sensors, batteries etc.). Afterward it builds everything. The last step is to gather the configuration of the Instruction Set Simulator (ISS) and runs the simulation.</p> <p>This python script, will then launch as a subprocesses some <code>Makefile</code> targets. Many RISC-V Instruction Set Simulators require to have a configuration file (i.e. memory and peripheral structure). These subprocesses will generate all of them. At the end of the build process, you should have 3 files inside the folder under <code>/messy/messy/gvsoc_deps</code>: 1. <code>gvsoc_config.json</code> 2. <code>hyperflash.bin</code> 3. <code>spiflash.bin</code></p>"},{"location":"tracing/","title":"Traces","text":"<p>The system supports several traces, these can be defined in the initial part of the configuration and used by sensors, converters, core and harvesters later on.</p> <p>The initial configuration can be done as follows:</p> <pre><code>\"tracing\":{\n    \"messy_trace\":{\n        \"filename\":\"messy_trace.log\",\n        \"resolution\":{\n            \"unit\":\"SC_MS\",\n            \"mult\":1\n        }\n    }\n}\n</code></pre> <p>Here a trace(multiple can be set) of name <code>messy_trace</code> is defined, the <code>filename</code> parameters define where the trace will be saved and finally the <code>resolution</code> describes the logging frequency through a resolution object better described in Resolution.</p> <p>To attach a trace to a sensor, harvester or what else during the configuration of that object the user shall set the <code>tracing</code> argument and describe for the related trace what to trace, for example below we want to trace the current of a sensor:</p> <pre><code>\"tracing\":{\n    \"messy_trace\":{\n        \"mic_click_I\":\"current\"\n    }\n}\n</code></pre> <p>Here the tracing is set only for a trace called <code>messy_trace</code> and for this trace only one parameter of the sensor is logged, this is the current and is saved as <code>mic_click_I</code> on the log.</p> <p>Currently voltages, current and State of Charge values can be traced quite easily.</p>"}]}